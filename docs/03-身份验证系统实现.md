# 03 - èº«ä»½éªŒè¯ç³»ç»Ÿå®ç°

## ğŸ“‹ æ¦‚è¿°

æœ¬ç« èŠ‚å°†è¯¦ç»†ä»‹ç»èŠå¤©å®¤åº”ç”¨çš„èº«ä»½éªŒè¯ç³»ç»Ÿï¼ŒåŒ…æ‹¬ JWT è®¤è¯æœºåˆ¶ã€ç”¨æˆ·æ³¨å†Œç™»å½•æµç¨‹ã€è®¤è¯ä¸­é—´ä»¶çš„å®ç°ä»¥åŠæƒé™æ§åˆ¶ç­–ç•¥ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£ JWT è®¤è¯æœºåˆ¶çš„å·¥ä½œåŸç†
- æŒæ¡ç”¨æˆ·æ³¨å†Œå’Œç™»å½•çš„å®Œæ•´æµç¨‹
- å­¦ä¼šå®ç°è®¤è¯ä¸­é—´ä»¶
- äº†è§£æƒé™æ§åˆ¶å’Œå®‰å…¨æœ€ä½³å®è·µ

## ğŸ” JWT è®¤è¯æœºåˆ¶

### JWT å·¥ä½œåŸç†

```
å®¢æˆ·ç«¯                    æœåŠ¡å™¨
  â”‚                        â”‚
  â”‚ 1. ç™»å½•è¯·æ±‚             â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
  â”‚                        â”‚ 2. éªŒè¯ç”¨æˆ·ä¿¡æ¯
  â”‚                        â”‚ 3. ç”Ÿæˆ JWT Token
  â”‚ 4. è¿”å› Token           â”‚
  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                        â”‚
  â”‚ 5. æºå¸¦ Token è¯·æ±‚      â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
  â”‚                        â”‚ 6. éªŒè¯ Token
  â”‚                        â”‚ 7. å¤„ç†è¯·æ±‚
  â”‚ 8. è¿”å›å“åº”             â”‚
  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

### JWT ç»“æ„

JWT ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œç”¨ç‚¹å·åˆ†éš”ï¼š
```
Header.Payload.Signature
```

- **Header**: åŒ…å«ç®—æ³•å’Œä»¤ç‰Œç±»å‹
- **Payload**: åŒ…å«å£°æ˜ï¼ˆç”¨æˆ·ä¿¡æ¯ï¼‰
- **Signature**: ç”¨äºéªŒè¯ä»¤ç‰Œçš„å®Œæ•´æ€§

## ğŸ› ï¸ JWT å·¥å…·å®ç°

åˆ›å»º `internal/auth/jwt.go`ï¼š

```go
package auth

import (
	"errors"
	"gin-chat-room/config"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// Claims JWT å£°æ˜ç»“æ„
type Claims struct {
	UserID   uint   `json:"user_id"`
	Username string `json:"username"`
	Email    string `json:"email"`
	jwt.RegisteredClaims
}

// GenerateToken ç”Ÿæˆ JWT token
func GenerateToken(userID uint, username, email string) (string, error) {
	// è®¾ç½®è¿‡æœŸæ—¶é—´
	expirationTime := time.Now().Add(time.Duration(config.AppConfig.JWT.ExpireTime) * time.Hour)

	// åˆ›å»ºå£°æ˜
	claims := &Claims{
		UserID:   userID,
		Username: username,
		Email:    email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			Issuer:    "gin-chat-room",
			Subject:   username,
		},
	}

	// åˆ›å»º token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// ç­¾å token
	tokenString, err := token.SignedString([]byte(config.AppConfig.JWT.Secret))
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

// ParseToken è§£æ JWT token
func ParseToken(tokenString string) (*Claims, error) {
	// è§£æ token
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		// éªŒè¯ç­¾åæ–¹æ³•
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return []byte(config.AppConfig.JWT.Secret), nil
	})

	if err != nil {
		return nil, err
	}

	// éªŒè¯ token æ˜¯å¦æœ‰æ•ˆ
	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, errors.New("invalid token")
}

// RefreshToken åˆ·æ–° token
func RefreshToken(tokenString string) (string, error) {
	// è§£ææ—§ token
	claims, err := ParseToken(tokenString)
	if err != nil {
		return "", err
	}

	// æ£€æŸ¥ token æ˜¯å¦å³å°†è¿‡æœŸï¼ˆåœ¨è¿‡æœŸå‰ 1 å°æ—¶å†…å¯ä»¥åˆ·æ–°ï¼‰
	if time.Until(claims.ExpiresAt.Time) > time.Hour {
		return "", errors.New("token is not close to expiration")
	}

	// ç”Ÿæˆæ–° token
	return GenerateToken(claims.UserID, claims.Username, claims.Email)
}
```

### JWT å·¥å…·ç‰¹ç‚¹

- **å®‰å…¨ç­¾å**: ä½¿ç”¨ HMAC SHA256 ç®—æ³•ç­¾å
- **è¿‡æœŸæ§åˆ¶**: å¯é…ç½®çš„ token è¿‡æœŸæ—¶é—´
- **åˆ·æ–°æœºåˆ¶**: æ”¯æŒ token åˆ·æ–°åŠŸèƒ½
- **å£°æ˜éªŒè¯**: éªŒè¯ token çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§

## ğŸ”’ è®¤è¯ä¸­é—´ä»¶

åˆ›å»º `internal/middleware/auth.go`ï¼š

```go
package middleware

import (
	"gin-chat-room/internal/auth"
	"gin-chat-room/internal/database"
	"gin-chat-room/internal/models"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

// AuthMiddleware JWT è®¤è¯ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ä» Header ä¸­è·å– token
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Authorization header is required",
			})
			c.Abort()
			return
		}

		// æ£€æŸ¥ Bearer å‰ç¼€
		tokenParts := strings.SplitN(authHeader, " ", 2)
		if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid authorization header format",
			})
			c.Abort()
			return
		}

		tokenString := tokenParts[1]

		// è§£æ token
		claims, err := auth.ParseToken(tokenString)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid token: " + err.Error(),
			})
			c.Abort()
			return
		}

		// éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
		var user models.User
		if err := database.DB.First(&user, claims.UserID).Error; err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "User not found",
			})
			c.Abort()
			return
		}

		// å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡ä¸­
		c.Set("user_id", claims.UserID)
		c.Set("username", claims.Username)
		c.Set("user", &user)

		c.Next()
	}
}

// GetCurrentUser ä»ä¸Šä¸‹æ–‡ä¸­è·å–å½“å‰ç”¨æˆ·
func GetCurrentUser(c *gin.Context) (*models.User, bool) {
	if user, exists := c.Get("user"); exists {
		if u, ok := user.(*models.User); ok {
			return u, true
		}
	}
	return nil, false
}

// GetCurrentUserID ä»ä¸Šä¸‹æ–‡ä¸­è·å–å½“å‰ç”¨æˆ·ID
func GetCurrentUserID(c *gin.Context) (uint, bool) {
	if userID, exists := c.Get("user_id"); exists {
		if id, ok := userID.(uint); ok {
			return id, true
		}
	}
	return 0, false
}
```

### ä¸­é—´ä»¶å·¥ä½œæµç¨‹

1. **æå– Token**: ä» Authorization Header ä¸­æå– JWT token
2. **éªŒè¯æ ¼å¼**: æ£€æŸ¥ Bearer å‰ç¼€æ ¼å¼
3. **è§£æ Token**: éªŒè¯ token ç­¾åå’Œæœ‰æ•ˆæ€§
4. **ç”¨æˆ·éªŒè¯**: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨äºæ•°æ®åº“ä¸­
5. **ä¸Šä¸‹æ–‡å­˜å‚¨**: å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­

## ğŸ‘¤ ç”¨æˆ·è®¤è¯å¤„ç†å™¨

åˆ›å»º `internal/handlers/auth.go`ï¼š

```go
package handlers

import (
	"gin-chat-room/internal/auth"
	"gin-chat-room/internal/database"
	"gin-chat-room/internal/middleware"
	"gin-chat-room/internal/models"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// RegisterRequest æ³¨å†Œè¯·æ±‚ç»“æ„
type RegisterRequest struct {
	Username string `json:"username" binding:"required,min=3,max=50"`
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=6"`
	Nickname string `json:"nickname,omitempty"`
}

// LoginRequest ç™»å½•è¯·æ±‚ç»“æ„
type LoginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

// AuthResponse è®¤è¯å“åº”ç»“æ„
type AuthResponse struct {
	Token string                 `json:"token"`
	User  map[string]interface{} `json:"user"`
}

// Register ç”¨æˆ·æ³¨å†Œ
func Register(c *gin.Context) {
	var req RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request data: " + err.Error(),
		})
		return
	}

	// æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
	var existingUser models.User
	if err := database.DB.Where("username = ? OR email = ?", req.Username, req.Email).First(&existingUser).Error; err == nil {
		c.JSON(http.StatusConflict, gin.H{
			"error": "Username or email already exists",
		})
		return
	}

	// åˆ›å»ºæ–°ç”¨æˆ·
	user := models.User{
		Username: strings.TrimSpace(req.Username),
		Email:    strings.TrimSpace(req.Email),
		Nickname: strings.TrimSpace(req.Nickname),
	}

	// è®¾ç½®å¯†ç 
	if err := user.SetPassword(req.Password); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to encrypt password",
		})
		return
	}

	// ä¿å­˜ç”¨æˆ·åˆ°æ•°æ®åº“
	if err := database.DB.Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create user",
		})
		return
	}

	// ç”Ÿæˆ JWT token
	token, err := auth.GenerateToken(user.ID, user.Username, user.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to generate token",
		})
		return
	}

	// è¿”å›å“åº”
	c.JSON(http.StatusCreated, AuthResponse{
		Token: token,
		User:  user.ToJSON(),
	})
}

// Login ç”¨æˆ·ç™»å½•
func Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request data: " + err.Error(),
		})
		return
	}

	// æŸ¥æ‰¾ç”¨æˆ·
	var user models.User
	if err := database.DB.Where("username = ? OR email = ?", req.Username, req.Username).First(&user).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid username or password",
			})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Database error",
			})
		}
		return
	}

	// éªŒè¯å¯†ç 
	if !user.CheckPassword(req.Password) {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "Invalid username or password",
		})
		return
	}

	// æ›´æ–°ç”¨æˆ·åœ¨çº¿çŠ¶æ€
	database.DB.Model(&user).Updates(models.User{IsOnline: true})

	// ç”Ÿæˆ JWT token
	token, err := auth.GenerateToken(user.ID, user.Username, user.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to generate token",
		})
		return
	}

	// è¿”å›å“åº”
	c.JSON(http.StatusOK, AuthResponse{
		Token: token,
		User:  user.ToJSON(),
	})
}

// GetProfile è·å–ç”¨æˆ·èµ„æ–™
func GetProfile(c *gin.Context) {
	user, exists := middleware.GetCurrentUser(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not found",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"user": user.ToJSON(),
	})
}

// UpdateProfileRequest æ›´æ–°èµ„æ–™è¯·æ±‚ç»“æ„
type UpdateProfileRequest struct {
	Nickname string `json:"nickname,omitempty"`
	Avatar   string `json:"avatar,omitempty"`
}

// UpdateProfile æ›´æ–°ç”¨æˆ·èµ„æ–™
func UpdateProfile(c *gin.Context) {
	user, exists := middleware.GetCurrentUser(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not found",
		})
		return
	}

	var req UpdateProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request data: " + err.Error(),
		})
		return
	}

	// æ›´æ–°ç”¨æˆ·ä¿¡æ¯
	updates := make(map[string]interface{})
	if req.Nickname != "" {
		updates["nickname"] = strings.TrimSpace(req.Nickname)
	}
	if req.Avatar != "" {
		updates["avatar"] = strings.TrimSpace(req.Avatar)
	}

	if len(updates) > 0 {
		if err := database.DB.Model(user).Updates(updates).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to update profile",
			})
			return
		}
	}

	// é‡æ–°è·å–ç”¨æˆ·ä¿¡æ¯
	database.DB.First(user, user.ID)

	c.JSON(http.StatusOK, gin.H{
		"user": user.ToJSON(),
	})
}
```

## ğŸ” å®‰å…¨æœ€ä½³å®è·µ

### 1. å¯†ç å®‰å…¨

```go
// ä½¿ç”¨ bcrypt åŠ å¯†å¯†ç 
func (u *User) SetPassword(password string) error {
    // ä½¿ç”¨é»˜è®¤æˆæœ¬ï¼ˆå½“å‰ä¸º 10ï¼‰
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    u.Password = string(hashedPassword)
    return nil
}

// éªŒè¯å¯†ç 
func (u *User) CheckPassword(password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
    return err == nil
}
```

### 2. Token å®‰å…¨

```go
// ä½¿ç”¨å¼ºå¯†é’¥
JWT_SECRET=your-very-long-and-random-secret-key-at-least-32-characters

// è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´
JWT_EXPIRE_TIME=24  // 24å°æ—¶

// éªŒè¯ token å®Œæ•´æ€§
if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
    return nil, errors.New("unexpected signing method")
}
```

### 3. è¾“å…¥éªŒè¯

```go
type RegisterRequest struct {
    Username string `json:"username" binding:"required,min=3,max=50"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    Nickname string `json:"nickname,omitempty"`
}
```

### 4. é”™è¯¯å¤„ç†

```go
// ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
if err == gorm.ErrRecordNotFound {
    c.JSON(http.StatusUnauthorized, gin.H{
        "error": "Invalid username or password",
    })
} else {
    c.JSON(http.StatusInternalServerError, gin.H{
        "error": "Database error",
    })
}
```

## ğŸ§ª è®¤è¯ç³»ç»Ÿæµ‹è¯•

åˆ›å»º `tests/auth_test.go`ï¼š

```go
package tests

import (
	"gin-chat-room/internal/auth"
	"gin-chat-room/config"
	"testing"
	"time"
)

func TestJWTToken(t *testing.T) {
	// åˆå§‹åŒ–é…ç½®
	config.AppConfig = &config.Config{
		JWT: config.JWTConfig{
			Secret:     "test-secret",
			ExpireTime: 24,
		},
	}

	// æµ‹è¯•ç”Ÿæˆ token
	userID := uint(1)
	username := "testuser"
	email := "test@example.com"

	token, err := auth.GenerateToken(userID, username, email)
	if err != nil {
		t.Fatalf("Failed to generate token: %v", err)
	}

	if token == "" {
		t.Fatal("Generated token is empty")
	}

	// æµ‹è¯•è§£æ token
	claims, err := auth.ParseToken(token)
	if err != nil {
		t.Fatalf("Failed to parse token: %v", err)
	}

	if claims.UserID != userID {
		t.Errorf("Expected UserID %d, got %d", userID, claims.UserID)
	}

	if claims.Username != username {
		t.Errorf("Expected Username %s, got %s", username, claims.Username)
	}

	if claims.Email != email {
		t.Errorf("Expected Email %s, got %s", email, claims.Email)
	}

	// æµ‹è¯•è¿‡æœŸæ—¶é—´
	if claims.ExpiresAt.Time.Before(time.Now()) {
		t.Error("Token should not be expired")
	}
}

func TestInvalidToken(t *testing.T) {
	// åˆå§‹åŒ–é…ç½®
	config.AppConfig = &config.Config{
		JWT: config.JWTConfig{
			Secret:     "test-secret",
			ExpireTime: 24,
		},
	}

	// æµ‹è¯•æ— æ•ˆ token
	_, err := auth.ParseToken("invalid-token")
	if err == nil {
		t.Error("Expected error for invalid token")
	}

	// æµ‹è¯•ç©º token
	_, err = auth.ParseToken("")
	if err == nil {
		t.Error("Expected error for empty token")
	}
}
```

## ğŸ“Š è®¤è¯æµç¨‹å›¾

```
ç”¨æˆ·æ³¨å†Œæµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æäº¤æ³¨å†Œä¿¡æ¯ â”‚â”€â”€â”€â–ºâ”‚ éªŒè¯è¾“å…¥æ•°æ® â”‚â”€â”€â”€â–ºâ”‚ æ£€æŸ¥ç”¨æˆ·å­˜åœ¨ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¿”å› Token  â”‚â—„â”€â”€â”€â”‚ ç”Ÿæˆ JWT    â”‚â—„â”€â”€â”€â”‚ åˆ›å»ºç”¨æˆ·    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç”¨æˆ·ç™»å½•æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æäº¤ç™»å½•ä¿¡æ¯ â”‚â”€â”€â”€â–ºâ”‚ æŸ¥æ‰¾ç”¨æˆ·    â”‚â”€â”€â”€â–ºâ”‚ éªŒè¯å¯†ç     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¿”å› Token  â”‚â—„â”€â”€â”€â”‚ ç”Ÿæˆ JWT    â”‚â—„â”€â”€â”€â”‚ æ›´æ–°çŠ¶æ€    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¯·æ±‚è®¤è¯æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æºå¸¦ Token  â”‚â”€â”€â”€â–ºâ”‚ æå– Token  â”‚â”€â”€â”€â–ºâ”‚ éªŒè¯ Token  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¤„ç†è¯·æ±‚    â”‚â—„â”€â”€â”€â”‚ å­˜å‚¨ç”¨æˆ·ä¿¡æ¯ â”‚â—„â”€â”€â”€â”‚ æŸ¥æ‰¾ç”¨æˆ·    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

1. **å¯†ç å®‰å…¨**: ä½¿ç”¨ bcrypt åŠ å¯†ï¼Œæ°¸ä¸æ˜æ–‡å­˜å‚¨
2. **Token ç®¡ç†**: è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´ï¼Œæ”¯æŒåˆ·æ–°æœºåˆ¶
3. **è¾“å…¥éªŒè¯**: ä¸¥æ ¼éªŒè¯æ‰€æœ‰ç”¨æˆ·è¾“å…¥
4. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯æ ¼å¼ï¼Œé¿å…ä¿¡æ¯æ³„éœ²
5. **ä¸­é—´ä»¶è®¾è®¡**: å¯å¤ç”¨çš„è®¤è¯ä¸­é—´ä»¶
6. **æµ‹è¯•è¦†ç›–**: å®Œæ•´çš„å•å…ƒæµ‹è¯•è¦†ç›–

## ğŸ¯ ä¸‹ä¸€æ­¥

åœ¨ä¸‹ä¸€ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†ä»‹ç» WebSocket å®æ—¶é€šä¿¡çš„å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- WebSocket è¿æ¥ç®¡ç†
- æ¶ˆæ¯å¹¿æ’­æœºåˆ¶
- åœ¨çº¿ç”¨æˆ·ç®¡ç†
- Redis é›†æˆ

é€šè¿‡æœ¬ç« èŠ‚çš„å­¦ä¹ ï¼Œæ‚¨åº”è¯¥å·²ç»æŒæ¡äº†ï¼š
- JWT è®¤è¯æœºåˆ¶çš„å®ç°
- ç”¨æˆ·æ³¨å†Œå’Œç™»å½•æµç¨‹
- è®¤è¯ä¸­é—´ä»¶çš„è®¾è®¡
- å®‰å…¨æœ€ä½³å®è·µ
