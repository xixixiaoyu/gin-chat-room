# 02 - æ•°æ®åº“è®¾è®¡å’Œæ¨¡å‹åˆ›å»º

## ğŸ“‹ æ¦‚è¿°

æœ¬ç« èŠ‚å°†è¯¦ç»†ä»‹ç»èŠå¤©å®¤åº”ç”¨çš„æ•°æ®åº“è®¾è®¡ï¼ŒåŒ…æ‹¬è¡¨ç»“æ„è®¾è®¡ã€GORM æ¨¡å‹å®šä¹‰ã€æ•°æ®åº“å…³ç³»å»ºç«‹ä»¥åŠæ•°æ®åº“åˆå§‹åŒ–æµç¨‹ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- æŒæ¡èŠå¤©å®¤åº”ç”¨çš„æ•°æ®åº“è®¾è®¡åŸåˆ™
- å­¦ä¼šä½¿ç”¨ GORM å®šä¹‰æ•°æ®æ¨¡å‹
- ç†è§£æ•°æ®åº“å…³ç³»çš„å»ºç«‹å’Œç»´æŠ¤
- æŒæ¡æ•°æ®åº“è¿ç§»å’Œåˆå§‹åŒ–æµç¨‹

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### å®ä½“å…³ç³»å›¾ (ERD)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    User     â”‚     â”‚    Room     â”‚     â”‚   Message   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)     â”‚     â”‚ id (PK)     â”‚     â”‚ id (PK)     â”‚
â”‚ username    â”‚     â”‚ name        â”‚     â”‚ room_id (FK)â”‚
â”‚ email       â”‚     â”‚ description â”‚     â”‚ user_id (FK)â”‚
â”‚ password    â”‚     â”‚ is_private  â”‚     â”‚ type        â”‚
â”‚ nickname    â”‚     â”‚ password    â”‚     â”‚ content     â”‚
â”‚ avatar      â”‚     â”‚ max_members â”‚     â”‚ file_url    â”‚
â”‚ is_online   â”‚     â”‚ creator_id  â”‚     â”‚ file_name   â”‚
â”‚ last_seen   â”‚     â”‚ created_at  â”‚     â”‚ file_size   â”‚
â”‚ created_at  â”‚     â”‚ updated_at  â”‚     â”‚ created_at  â”‚
â”‚ updated_at  â”‚     â”‚ deleted_at  â”‚     â”‚ updated_at  â”‚
â”‚ deleted_at  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ deleted_at  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                       â”‚
       â”‚                                       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚     â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ RoomMember  â”‚
                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                â”‚ id (PK)     â”‚
                â”‚ room_id (FK)â”‚
                â”‚ user_id (FK)â”‚
                â”‚ role        â”‚
                â”‚ joined_at   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®åº“å…³ç³»

1. **User â†” Room**: å¤šå¯¹å¤šå…³ç³»ï¼ˆé€šè¿‡ RoomMember ä¸­é—´è¡¨ï¼‰
2. **User â†’ Room**: ä¸€å¯¹å¤šå…³ç³»ï¼ˆåˆ›å»ºè€…å…³ç³»ï¼‰
3. **User â†’ Message**: ä¸€å¯¹å¤šå…³ç³»ï¼ˆç”¨æˆ·å‘é€çš„æ¶ˆæ¯ï¼‰
4. **Room â†’ Message**: ä¸€å¯¹å¤šå…³ç³»ï¼ˆæˆ¿é—´å†…çš„æ¶ˆæ¯ï¼‰
5. **Room â†” User**: å¤šå¯¹å¤šå…³ç³»ï¼ˆæˆ¿é—´æˆå‘˜å…³ç³»ï¼‰

## ğŸ“Š æ•°æ®æ¨¡å‹å®šä¹‰

### 1. ç”¨æˆ·æ¨¡å‹ (User)

åˆ›å»º `internal/models/user.go`ï¼š

```go
package models

import (
	"time"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
	ID        uint           `json:"id" gorm:"primaryKey"`
	Username  string         `json:"username" gorm:"uniqueIndex;not null;size:50"`
	Email     string         `json:"email" gorm:"uniqueIndex;not null;size:100"`
	Password  string         `json:"-" gorm:"not null"`
	Nickname  string         `json:"nickname" gorm:"size:50"`
	Avatar    string         `json:"avatar" gorm:"size:255"`
	IsOnline  bool           `json:"is_online" gorm:"default:false"`
	LastSeen  *time.Time     `json:"last_seen"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`

	// å…³è”å…³ç³»
	Messages    []Message    `json:"-" gorm:"foreignKey:UserID"`
	RoomMembers []RoomMember `json:"-" gorm:"foreignKey:UserID"`
}

// BeforeCreate åˆ›å»ºå‰çš„é’©å­å‡½æ•°
func (u *User) BeforeCreate(tx *gorm.DB) error {
	// å¦‚æœæ²¡æœ‰è®¾ç½®æ˜µç§°ï¼Œä½¿ç”¨ç”¨æˆ·åä½œä¸ºæ˜µç§°
	if u.Nickname == "" {
		u.Nickname = u.Username
	}
	return nil
}

// SetPassword è®¾ç½®å¯†ç ï¼ˆåŠ å¯†ï¼‰
func (u *User) SetPassword(password string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	u.Password = string(hashedPassword)
	return nil
}

// CheckPassword éªŒè¯å¯†ç 
func (u *User) CheckPassword(password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
	return err == nil
}

// ToJSON è½¬æ¢ä¸º JSON æ ¼å¼ï¼ˆä¸åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼‰
func (u *User) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"id":        u.ID,
		"username":  u.Username,
		"email":     u.Email,
		"nickname":  u.Nickname,
		"avatar":    u.Avatar,
		"is_online": u.IsOnline,
		"last_seen": u.LastSeen,
	}
}
```

#### ç”¨æˆ·æ¨¡å‹ç‰¹ç‚¹

- **å”¯ä¸€ç´¢å¼•**: username å’Œ email å­—æ®µç¡®ä¿å”¯ä¸€æ€§
- **å¯†ç å®‰å…¨**: ä½¿ç”¨ bcrypt åŠ å¯†å­˜å‚¨å¯†ç 
- **è½¯åˆ é™¤**: æ”¯æŒè½¯åˆ é™¤ï¼Œä¿ç•™æ•°æ®å®Œæ•´æ€§
- **é’©å­å‡½æ•°**: BeforeCreate è‡ªåŠ¨è®¾ç½®é»˜è®¤æ˜µç§°
- **JSON åºåˆ—åŒ–**: ToJSON æ–¹æ³•æ’é™¤æ•æ„Ÿä¿¡æ¯

### 2. æˆ¿é—´æ¨¡å‹ (Room)

åˆ›å»º `internal/models/room.go`ï¼š

```go
package models

import (
	"time"

	"gorm.io/gorm"
)

// Room èŠå¤©å®¤æ¨¡å‹
type Room struct {
	ID          uint           `json:"id" gorm:"primaryKey"`
	Name        string         `json:"name" gorm:"not null;size:100"`
	Description string         `json:"description" gorm:"size:500"`
	IsPrivate   bool           `json:"is_private" gorm:"default:false"`
	Password    string         `json:"-" gorm:"size:255"` // ç§æœ‰æˆ¿é—´å¯†ç 
	MaxMembers  int            `json:"max_members" gorm:"default:100"`
	CreatorID   uint           `json:"creator_id" gorm:"not null"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `json:"-" gorm:"index"`

	// å…³è”å…³ç³»
	Creator     User         `json:"creator" gorm:"foreignKey:CreatorID"`
	Messages    []Message    `json:"-" gorm:"foreignKey:RoomID"`
	RoomMembers []RoomMember `json:"-" gorm:"foreignKey:RoomID"`
}

// RoomMember èŠå¤©å®¤æˆå‘˜æ¨¡å‹
type RoomMember struct {
	ID       uint      `json:"id" gorm:"primaryKey"`
	RoomID   uint      `json:"room_id" gorm:"not null"`
	UserID   uint      `json:"user_id" gorm:"not null"`
	Role     string    `json:"role" gorm:"default:'member';size:20"` // admin, member
	JoinedAt time.Time `json:"joined_at"`

	// å…³è”å…³ç³»
	Room Room `json:"room" gorm:"foreignKey:RoomID"`
	User User `json:"user" gorm:"foreignKey:UserID"`
}

// GetMemberCount è·å–æˆ¿é—´æˆå‘˜æ•°é‡
func (r *Room) GetMemberCount(db *gorm.DB) int64 {
	var count int64
	db.Model(&RoomMember{}).Where("room_id = ?", r.ID).Count(&count)
	return count
}

// IsMember æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯æˆ¿é—´æˆå‘˜
func (r *Room) IsMember(db *gorm.DB, userID uint) bool {
	var count int64
	db.Model(&RoomMember{}).Where("room_id = ? AND user_id = ?", r.ID, userID).Count(&count)
	return count > 0
}

// IsAdmin æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯æˆ¿é—´ç®¡ç†å‘˜
func (r *Room) IsAdmin(db *gorm.DB, userID uint) bool {
	var count int64
	db.Model(&RoomMember{}).Where("room_id = ? AND user_id = ? AND role = ?", r.ID, userID, "admin").Count(&count)
	return count > 0 || r.CreatorID == userID
}

// ToJSON è½¬æ¢ä¸º JSON æ ¼å¼
func (r *Room) ToJSON(db *gorm.DB) map[string]interface{} {
	return map[string]interface{}{
		"id":           r.ID,
		"name":         r.Name,
		"description":  r.Description,
		"is_private":   r.IsPrivate,
		"max_members":  r.MaxMembers,
		"creator_id":   r.CreatorID,
		"member_count": r.GetMemberCount(db),
		"created_at":   r.CreatedAt,
	}
}
```

#### æˆ¿é—´æ¨¡å‹ç‰¹ç‚¹

- **ç§æœ‰æˆ¿é—´**: æ”¯æŒå¯†ç ä¿æŠ¤çš„ç§æœ‰èŠå¤©å®¤
- **æˆå‘˜ç®¡ç†**: é€šè¿‡ RoomMember ä¸­é—´è¡¨ç®¡ç†æˆå‘˜å…³ç³»
- **æƒé™æ§åˆ¶**: åŒºåˆ†åˆ›å»ºè€…ã€ç®¡ç†å‘˜å’Œæ™®é€šæˆå‘˜
- **ä¸šåŠ¡æ–¹æ³•**: æä¾›æˆå‘˜æ•°é‡ã€æƒé™æ£€æŸ¥ç­‰ä¸šåŠ¡æ–¹æ³•

### 3. æ¶ˆæ¯æ¨¡å‹ (Message)

åˆ›å»º `internal/models/message.go`ï¼š

```go
package models

import (
	"time"

	"gorm.io/gorm"
)

// MessageType æ¶ˆæ¯ç±»å‹
type MessageType string

const (
	MessageTypeText   MessageType = "text"   // æ–‡æœ¬æ¶ˆæ¯
	MessageTypeImage  MessageType = "image"  // å›¾ç‰‡æ¶ˆæ¯
	MessageTypeFile   MessageType = "file"   // æ–‡ä»¶æ¶ˆæ¯
	MessageTypeSystem MessageType = "system" // ç³»ç»Ÿæ¶ˆæ¯
)

// Message æ¶ˆæ¯æ¨¡å‹
type Message struct {
	ID        uint           `json:"id" gorm:"primaryKey"`
	RoomID    uint           `json:"room_id" gorm:"not null;index"`
	UserID    uint           `json:"user_id" gorm:"not null;index"`
	Type      MessageType    `json:"type" gorm:"default:'text';size:20"`
	Content   string         `json:"content" gorm:"not null;type:text"`
	FileURL   string         `json:"file_url,omitempty" gorm:"size:500"`
	FileName  string         `json:"file_name,omitempty" gorm:"size:255"`
	FileSize  int64          `json:"file_size,omitempty"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`

	// å…³è”å…³ç³»
	Room Room `json:"room" gorm:"foreignKey:RoomID"`
	User User `json:"user" gorm:"foreignKey:UserID"`
}

// ToJSON è½¬æ¢ä¸º JSON æ ¼å¼
func (m *Message) ToJSON() map[string]interface{} {
	result := map[string]interface{}{
		"id":         m.ID,
		"room_id":    m.RoomID,
		"user_id":    m.UserID,
		"type":       m.Type,
		"content":    m.Content,
		"created_at": m.CreatedAt,
		"user": map[string]interface{}{
			"id":       m.User.ID,
			"username": m.User.Username,
			"nickname": m.User.Nickname,
			"avatar":   m.User.Avatar,
		},
	}

	// å¦‚æœæ˜¯æ–‡ä»¶æ¶ˆæ¯ï¼Œæ·»åŠ æ–‡ä»¶ä¿¡æ¯
	if m.Type == MessageTypeFile || m.Type == MessageTypeImage {
		result["file_url"] = m.FileURL
		result["file_name"] = m.FileName
		result["file_size"] = m.FileSize
	}

	return result
}

// CreateSystemMessage åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
func CreateSystemMessage(roomID uint, content string) *Message {
	return &Message{
		RoomID:  roomID,
		UserID:  0, // ç³»ç»Ÿæ¶ˆæ¯ç”¨æˆ·IDä¸º0
		Type:    MessageTypeSystem,
		Content: content,
	}
}
```

#### æ¶ˆæ¯æ¨¡å‹ç‰¹ç‚¹

- **æ¶ˆæ¯ç±»å‹**: æ”¯æŒæ–‡æœ¬ã€å›¾ç‰‡ã€æ–‡ä»¶ã€ç³»ç»Ÿæ¶ˆæ¯
- **æ–‡ä»¶æ”¯æŒ**: é¢„ç•™æ–‡ä»¶ä¸Šä¼ ç›¸å…³å­—æ®µ
- **ç´¢å¼•ä¼˜åŒ–**: ä¸ºæŸ¥è¯¢é¢‘ç¹çš„å­—æ®µæ·»åŠ ç´¢å¼•
- **ç³»ç»Ÿæ¶ˆæ¯**: æ”¯æŒç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆçš„æ¶ˆæ¯

## ğŸ”§ æ•°æ®åº“åˆå§‹åŒ–

åˆ›å»º `internal/database/database.go`ï¼š

```go
package database

import (
	"fmt"
	"gin-chat-room/config"
	"gin-chat-room/internal/models"
	"log"

	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var DB *gorm.DB

// InitDB åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
func InitDB() error {
	var err error
	var dialector gorm.Dialector

	cfg := config.AppConfig.Database

	switch cfg.Type {
	case "postgres":
		dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=%s",
			cfg.Host, cfg.Username, cfg.Password, cfg.Database, cfg.Port, cfg.SSLMode)
		dialector = postgres.Open(dsn)
	case "sqlite":
		dialector = sqlite.Open(cfg.Database)
	default:
		return fmt.Errorf("unsupported database type: %s", cfg.Type)
	}

	// é…ç½® GORM
	gormConfig := &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	}

	// å¦‚æœæ˜¯ç”Ÿäº§ç¯å¢ƒï¼Œå…³é—­è¯¦ç»†æ—¥å¿—
	if config.AppConfig.Server.Mode == "release" {
		gormConfig.Logger = logger.Default.LogMode(logger.Silent)
	}

	DB, err = gorm.Open(dialector, gormConfig)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	// è‡ªåŠ¨è¿ç§»æ•°æ®åº“è¡¨
	if err := AutoMigrate(); err != nil {
		return fmt.Errorf("failed to migrate database: %w", err)
	}

	// åˆ›å»ºé»˜è®¤æ•°æ®
	if err := CreateDefaultData(); err != nil {
		return fmt.Errorf("failed to create default data: %w", err)
	}

	log.Println("Database initialized successfully")
	return nil
}

// AutoMigrate è‡ªåŠ¨è¿ç§»æ•°æ®åº“è¡¨
func AutoMigrate() error {
	return DB.AutoMigrate(
		&models.User{},
		&models.Room{},
		&models.RoomMember{},
		&models.Message{},
	)
}

// CreateDefaultData åˆ›å»ºé»˜è®¤æ•°æ®
func CreateDefaultData() error {
	// åˆ›å»ºé»˜è®¤èŠå¤©å®¤
	var count int64
	DB.Model(&models.Room{}).Count(&count)
	if count == 0 {
		// åˆ›å»ºç³»ç»Ÿç”¨æˆ·
		systemUser := &models.User{
			Username: "system",
			Email:    "system@chatroom.com",
			Nickname: "ç³»ç»Ÿ",
		}
		systemUser.SetPassword("system123")
		if err := DB.Create(systemUser).Error; err != nil {
			return err
		}

		// åˆ›å»ºé»˜è®¤èŠå¤©å®¤
		defaultRoom := &models.Room{
			Name:        "å¤§å…",
			Description: "æ¬¢è¿æ¥åˆ°èŠå¤©å®¤å¤§å…ï¼",
			IsPrivate:   false,
			MaxMembers:  1000,
			CreatorID:   systemUser.ID,
		}
		if err := DB.Create(defaultRoom).Error; err != nil {
			return err
		}

		// åˆ›å»ºæ¬¢è¿æ¶ˆæ¯
		welcomeMessage := &models.Message{
			RoomID:  defaultRoom.ID,
			UserID:  systemUser.ID,
			Type:    models.MessageTypeSystem,
			Content: "æ¬¢è¿æ¥åˆ°èŠå¤©å®¤ï¼è¯·éµå®ˆèŠå¤©è§„åˆ™ï¼Œå‹å¥½äº¤æµã€‚",
		}
		if err := DB.Create(welcomeMessage).Error; err != nil {
			return err
		}

		log.Println("Default data created successfully")
	}

	return nil
}

// GetDB è·å–æ•°æ®åº“å®ä¾‹
func GetDB() *gorm.DB {
	return DB
}
```

## ğŸ“ˆ æ•°æ®åº“ä¼˜åŒ–

### 1. ç´¢å¼•ç­–ç•¥

```go
// åœ¨æ¨¡å‹å®šä¹‰ä¸­æ·»åŠ ç´¢å¼•
type User struct {
    Username string `gorm:"uniqueIndex;not null;size:50"`  // å”¯ä¸€ç´¢å¼•
    Email    string `gorm:"uniqueIndex;not null;size:100"` // å”¯ä¸€ç´¢å¼•
}

type Message struct {
    RoomID uint `gorm:"not null;index"` // æ™®é€šç´¢å¼•
    UserID uint `gorm:"not null;index"` // æ™®é€šç´¢å¼•
}
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

```go
// é¢„åŠ è½½å…³è”æ•°æ®
var messages []models.Message
db.Preload("User").Where("room_id = ?", roomID).Find(&messages)

// åˆ†é¡µæŸ¥è¯¢
db.Offset(offset).Limit(pageSize).Find(&rooms)

// æ¡ä»¶æŸ¥è¯¢
db.Where("is_private = ? OR creator_id = ?", false, userID).Find(&rooms)
```

### 3. è¿æ¥æ± é…ç½®

```go
// é…ç½®æ•°æ®åº“è¿æ¥æ± 
sqlDB, err := DB.DB()
if err != nil {
    return err
}

// è®¾ç½®æœ€å¤§æ‰“å¼€è¿æ¥æ•°
sqlDB.SetMaxOpenConns(100)

// è®¾ç½®æœ€å¤§ç©ºé—²è¿æ¥æ•°
sqlDB.SetMaxIdleConns(10)

// è®¾ç½®è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
sqlDB.SetConnMaxLifetime(time.Hour)
```

## ğŸ§ª æ•°æ®æ¨¡å‹æµ‹è¯•

åˆ›å»º `tests/models_test.go`ï¼š

```go
package tests

import (
	"gin-chat-room/internal/models"
	"testing"
)

func TestUserModel(t *testing.T) {
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
	}

	// æµ‹è¯•è®¾ç½®å¯†ç 
	password := "testpassword123"
	err := user.SetPassword(password)
	if err != nil {
		t.Fatalf("Failed to set password: %v", err)
	}

	// æµ‹è¯•éªŒè¯å¯†ç 
	if !user.CheckPassword(password) {
		t.Error("Password verification should succeed with correct password")
	}

	if user.CheckPassword("wrongpassword") {
		t.Error("Password verification should fail with incorrect password")
	}

	// æµ‹è¯• ToJSON æ–¹æ³•
	jsonData := user.ToJSON()
	if jsonData["username"] != user.Username {
		t.Error("ToJSON should include username")
	}

	if _, exists := jsonData["password"]; exists {
		t.Error("ToJSON should not include password")
	}
}
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. æ¨¡å‹è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: æ¯ä¸ªæ¨¡å‹åªè´Ÿè´£ä¸€ä¸ªå®ä½“
- **å…³ç³»æ¸…æ™°**: æ˜ç¡®å®šä¹‰å®ä½“é—´çš„å…³ç³»
- **å­—æ®µçº¦æŸ**: åˆç†è®¾ç½®å­—æ®µé•¿åº¦å’Œçº¦æŸ
- **ç´¢å¼•ä¼˜åŒ–**: ä¸ºæŸ¥è¯¢é¢‘ç¹çš„å­—æ®µæ·»åŠ ç´¢å¼•

### 2. GORM ä½¿ç”¨æŠ€å·§

- **é’©å­å‡½æ•°**: åˆ©ç”¨ BeforeCreateã€AfterCreate ç­‰é’©å­
- **è½¯åˆ é™¤**: ä½¿ç”¨ DeletedAt å­—æ®µå®ç°è½¯åˆ é™¤
- **é¢„åŠ è½½**: ä½¿ç”¨ Preload é¿å… N+1 æŸ¥è¯¢é—®é¢˜
- **äº‹åŠ¡å¤„ç†**: åœ¨éœ€è¦çš„åœ°æ–¹ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡

### 3. å®‰å…¨è€ƒè™‘

- **å¯†ç åŠ å¯†**: ä½¿ç”¨ bcrypt åŠ å¯†å­˜å‚¨å¯†ç 
- **SQL æ³¨å…¥**: GORM è‡ªåŠ¨é˜²æ­¢ SQL æ³¨å…¥
- **æ•°æ®éªŒè¯**: åœ¨æ¨¡å‹å±‚è¿›è¡Œæ•°æ®éªŒè¯
- **æ•æ„Ÿä¿¡æ¯**: ä½¿ç”¨ json:"-" æ ‡ç­¾éšè—æ•æ„Ÿå­—æ®µ

## ğŸ¯ ä¸‹ä¸€æ­¥

åœ¨ä¸‹ä¸€ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†ä»‹ç»èº«ä»½éªŒè¯ç³»ç»Ÿçš„å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- JWT è®¤è¯æœºåˆ¶
- ç”¨æˆ·æ³¨å†Œå’Œç™»å½•
- è®¤è¯ä¸­é—´ä»¶
- æƒé™æ§åˆ¶

é€šè¿‡æœ¬ç« èŠ‚çš„å­¦ä¹ ï¼Œæ‚¨åº”è¯¥å·²ç»æŒæ¡äº†ï¼š
- æ•°æ®åº“è¡¨ç»“æ„çš„è®¾è®¡åŸåˆ™
- GORM æ¨¡å‹çš„å®šä¹‰å’Œä½¿ç”¨
- æ•°æ®åº“å…³ç³»çš„å»ºç«‹
- æ•°æ®åº“åˆå§‹åŒ–å’Œè¿ç§»æµç¨‹
